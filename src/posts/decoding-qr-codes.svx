---
title: "Decoding QR Codes for fun and profit"
subhead: "trust hates him, scrape T2 with this one simple trick!"
created: "2024-07-01"
edited: "2025-08-12"
cover: "/img/qr/qr_hm.png"
imgtitle: "Ironically, I didn't cover error correction"
coverWidth: "421px"
coverHeight: "306px"
---

<script>
  import { onMount } from "svelte";
  import GroupHover from "$lib/qr/GroupHover.svelte";
  import QRSimple from "$lib/qr/QRSimple.svelte";
  import QROverlay from "$lib/qr/QROverlay.svelte";
  import { QRtextToBitArray } from "$lib/qr/decode";
  import { allPatterns, getPatternMask } from "$lib/qr/patterns";
  import { patternHues } from "$lib/qr/utils";

  const qrText = 
`█▀▀▀▀▀█ █▀   ███▀ █▄█▀▀▀▄▄▀ ▄▀█▄ ▄▄▄  ▄▄█ █▀▀▀▀▀█
█ ███ █ ▀█▄▄▄  ▄█ ▄▄██▄█▄▄▀▀▄█  ▄▀▀▄▄▄ █▀ █ ███ █
█ ▀▀▀ █ ▄█▄   ▀█▄█ ▀ ██▀▀▀█▄▀▄ ▀ ▄▄ ▀▀▄   █ ▀▀▀ █
▀▀▀▀▀▀▀ █ █ ▀ ▀▄▀ █▄▀ █ ▀ █▄▀ █ █▄▀ █ █▄▀ ▀▀▀▀▀▀▀
  ▀▀█▄▀▄█▀█   ▄██▄ ▀▄ ▀█▀▀█ ▄█▄█▀▀▀▀  ▀█▀███ ▄▀▀▀
▄▄█ ▄▄▀▀▄▀ ██▄██▄ ▄▀██  ▄▀▀█▀ ▄▄█▀█▀▄ ██▀▀▄▀▄█▀▀▀
█▀▄▄  ▀  ▀▄ ▀█▀ ▄ █ ▀  ▄█▀▄█▄ ▀▀▀▀█▄█▄ █▀▄▄ ▄▄▀▀ 
▀  ██▀▀█ █▀ ▀ █  ▄ ▄█▄▀██▄▀ ▀█ ▀▄█ ▀  ▀██▄ ▄▄▄ █▀
  ▀█ ▀▀ ▀  ▀ ▄ █▀▄ ▀▄▀▀ ▄▄   ▄▄ ▄▄  █▀ ▀▄▄ █ ▄▄ ▀
██ ▀█▄▀█▀█ ▄▄▀▄ ▀█▀▀▀ ▀▀▄█▀▄ ▄█ ▄  ▀ ▀ ▀█▄█▀▄▄▀ ▀
█▀██ ▀▀▄█▄ █▀▀█▄▀▀ ▀▄▄█▄█▄▄ ▀ ▀    █▀▄▀▄▀ ██ ▀█▄▀
█ ▀▀█▀▀▀█▄▀▄▀ ▀█ ▄█▀▀▄█▀▀▀█  ▄ ▀▀▀█  ▀▀▀█▀▀▀██ ██
 ▀█▄█ ▀ █▄██▀▄██▄ ▀   █ ▀ █▀▀▀▀▀█ ▀▀▀ ▀ █ ▀ █▀▀ █
 █ ██▀▀▀█▄▄▀▀▀█▄▄▀▄██▄▀████ █▄ █▀ █▄▀▀▀ ▀▀▀▀█  ▀ 
▄█   █▀█ ▀█ ██▀█ ▀█▀▄▀▄  ▀ ▄▀█▄▄ ▀▀█▀█ ▀ ▄▀▀ ▀█▀ 
██▄ ▀▀▀ █  ▄▀ ▄▀  ▀▄██ ▄█▀▄▀▄  ▄ ███▄ ▀▀█▀▀▀  ▀▄▀
▀  ▄█▀▀██ ▄▀█ ▄███ █▀▄███ ▀▄ ▀▀▄ █ ▄█ ▀▀ ▀▄▄▀▄█  
▄ ██ ▀▀ ██▀█▄█▀ ▄█ ▀ ▀█▄▄▀▀▀ ▄█  ▄▀▄▀ █▀█ ▀ ▀█▀█▀
 █ █▄▄▀▀ ▄▄██▄▄█  ▄ ▀▄█ ██▄█ ▀▄▀█▄ ▀▀▀ ██▄▀▄▀▀██ 
 █▄▄ ▀▀  █ ▄▀ ▀▀▀ ▄ ███▄▄▄▄ ▄▄ ▀█ ▄ ▀▄█▀▀ ▀▄ ▀███
▀▀▀   ▀▀▄▄▄ ▄▀▄▀ ▄█▀█ █▀▀▀█ ▄██▀▄▀█ ▀▄███▀▀▀██ ▀▀
█▀▀▀▀▀█  ▀█▄██▀█ █ ▀▄▄█ ▀ █▄▀█▀█ ▀  ▀ ▄▄█ ▀ █▀▀ ▀
█ ███ █ █▀▀▄ ▄ ▄▀ █ ██████▀ ▀███▄▀ █▀█ ▀▀▀█▀██▀▀▄
█ ▀▀▀ █ ▀██ ▄▄▀▀▄▀█ ▀▄█  ▄▄ ▀▀▀█▄▀▀ ▀ █▀ █▄  ▀▀▀█
▀▀▀▀▀▀▀   ▀▀▀▀▀▀ ▀▀ ▀▀  ▀      ▀ ▀  ▀ ▀▀   ▀  ▀▀▀`;

    const QRLines = qrText.split("\n");
    const qrSize = QRLines[0].length;

    const bitArray = QRtextToBitArray(QRLines);

    /// Functional Module Visualization ///

    console.log("allPatterns", allPatterns);

    // map of patterns to masks
    const patternMasks = Object.fromEntries(
      allPatterns.map(pattern => [pattern, getPatternMask(qrSize, pattern)])
    );

    let highlightedPattern = $state();

    let overlays = $derived(allPatterns.map(
      pattern => ({
        pattern,
        bitarray: patternMasks[pattern],
        moduleOnColor: `hsl(${patternHues[pattern]}deg 100% 50% / 50%)`,
        visible: highlightedPattern ? (highlightedPattern == pattern) : true
      })
    ));
    $inspect(overlays);

    // let overlays = $state([{pattern: "finder", bitarray: patternMasks["finder"], moduleOnColor: `hsl(${patternHues["finder"]}deg 100% 50% / 50%)`}]);
    // let i = $state(0);
    // $effect(() => {
    //   const id = setInterval(() => {
    //     i = (i + 1) % (allPatterns.length);
    //     const pattern = allPatterns[i];
    //     overlays = [{pattern, bitarray: patternMasks[pattern], moduleOnColor: `hsl(${patternHues[pattern]}deg 100% 50% / 50%)`}]
    //   }, 1000);

    //   return () => {
    //     clearInterval(id);
    //   }
    // });
    // $inspect(i);
    // $inspect(overlays);

//     // /// Visualization pt. 2 ///

// 
// 
//     // // all patterns as red
    // const allPatternsRed = allPatterns.map(pattern => [pattern, 2]);

//     // let n = 0;
    // /** 
    //  * group colors, the byte value, and the modules 
    //  * for each codeword in each block in each group 
    //  */
    // const groupColors = dataBlocks.map(
    //     (group, g) => group.map(
    //         (block, b) => block.map(
    //             (codeword, i) => ({
    //                 ...groupColor(g, b, i, groups), 
    //                 byte: toByte(codeword),
    //                 modules: blockHistory.filter(([group, block]) => group == g && block == b)[i][3]
    //             })
    //         )
    //     )
    // );

//     // let hoveredGroup: {g: number, b: number, i: number} | null = null;
    // 
    // let hoverVisualization: ["block", [number, number][], number][];

//     // const defaultHoverVis = groupColors
    //     .flat(3)
    //     .map(({modules, blockHue}) => [
    //         "block",
    //         modules,
    //         blockHue
    //     ])
    //     .concat(allPatternsRed)
    // 
    // const groupBlockHoverVis = (group: number, block: number) => 
    //     groupColors[group][block].map(({modules, blockHue}) => [
    //         "block",
    //         modules,
    //         blockHue
    //     ])
    //     .concat(allPatternsRed)
    // 
    // let hoverVis = $state(defaultHoverVis);

// 
// 
//     // /// Animation ///

// 
// 
//     // let animatedQR: QR;
    // let animState = $state("paused");
    // let animSpeed = $state(1);

//     // let bitString = $state("");
</script>


# QR code decoders

If you've ever wanted to make your own QR Code decoder, you've probably come across some [tutorials](https://www.thonky.com/qr-code-tutorial/) for encoding. There are several resources for [decoding](https://qr.blinry.org/) too, but many focus on smaller QR codes and miss out some critical information. This tutorial goes into the details of decoding, and the pitfalls you might encounter.

Briefly, the decoding process looks like this:
  - Parse the QR code modules into bits
  - Read the `format bits` to find the `error correction level` and `mask pattern`
  - Read and unmask the `data codewords`
  - Deinterleave the `data codewords`
  - Read the `encoding bits` and `data length`
  - Read the total message data and decode it as specified

There's a lot more involved on the error correction and image processing side, but I won't be going over those in this guide.


## Anatomy of a QR Code

Before we start decoding, first you must understand the different parts of a QR code.

1. Modules
   - Black and white boxes that make up the QR code
   - Called modules to separate them from pixels
   - On or 1 when it is black, Off or 0 when it is white

2. Version
   - Each size of QR codes is a specific version, from 1 to 40
   - `version = ((size - 21) / 4) + 1` (size being total width or height in modules)

### Functional modules

Functional modules are patterns in specific locations used for metadata or image processing purposes.

1. **Finder pattern**
   - Three distinct boxes in each corner except for the bottom-left.
   - 7x7 module outer box, 3x3 module box inside
   - The 3x3 inner box has a 1 module white border around it
   - Always have a 1 module white border around the two sides facing inwards

2. **Timing pattern**
   - Two 1 module wide lines, alternating on/off
   - Horizontal and vertical
   - Aligned to the bottom-left corner of the top-left finder pattern

3. **Alignment pattern**
   - These are smaller boxes spread evenly across the QR code
   - 5x5 modules boxes with 1 module in the center
   - Not present on the smallest QR code (`version == 1`)
   - The positions are dependent on QR version
     - They are always in sync with the timing pattern

4. **Format bits**
   - A 15 bit string containing QR code format metadata
   - Two copies exist in all QR codes:
     - Wrapped around the top-left finder pattern
     - Below the top-right finder pattern, and right of the bottom-left finder pattern

5. **Dark Module**
   - A single module that's always on (dark)
   - Always in the same place - aligned to the top-right corner of the bottom-left finder pattern

6. **Version bits**
   - 18 bits defining the QR version
   - Two copies:
    - 6x3 rectangle above the bottom-left finder pattern 
    - 3x6 rectangle to the left of the top-right finder pattern
   - Not present on smaller QR codes (`version < 6`)
   - 6 bit version number with 12 bits for error correction
   - Mostly useful for image-based readers to prevent false positive reads

<QROverlay
  width={qrSize}
  height={qrSize}
  QRBitArray={bitArray}
  {overlays}
/>

Tip: Hover over me, I'm interactive!

<div class="columns">
    <span 
        class={["column", "is-4", "glowy-text", { active: highlightedPattern == "finder" }]}
        style:--shadowHue={`hsl(${patternHues["finder"]}deg 100% 50%)`}
        onmouseenter={() => highlightedPattern = "finder"}
        onmouseleave={() => highlightedPattern = undefined}
        role="none"
    >
    [Finder pattern]
    </span>
    
    <span
        class={["column", "is-4", "glowy-text", { active: highlightedPattern == "timing" }]}
        style:--shadowHue={`hsl(${patternHues["timing"]}deg 100% 50%)`}
        onmouseenter={() => highlightedPattern = "timing"}
        onmouseleave={() => highlightedPattern = undefined}
        role="none"
    >
    [Timing pattern]
    </span> 
    
    <span
        class={["column", "is-4", "glowy-text", { active: highlightedPattern == "alignment" }]}
        style:--shadowHue={`hsl(${patternHues["alignment"]}deg 100% 50%)`}
        onmouseenter={() => highlightedPattern = "alignment"}
        onmouseleave={() => highlightedPattern = undefined}
        role="none"
    >
    [Alignment pattern]
    </span>
</div>
<div class="columns">
    <span 
        class={["column", "is-4", "glowy-text", { active: highlightedPattern == "format" }]}
        style:--shadowHue={`hsl(${patternHues["format"]}deg 100% 50%)`}
        onmouseenter={() => highlightedPattern = "format"}
        onmouseleave={() => highlightedPattern = undefined}
        role="none"
    >
    [Format bits]
    </span> 
    
    <span 
        class={["column", "is-4", "glowy-text", { active: highlightedPattern == "darkModule" }]}
        style:--shadowHue={`hsl(${patternHues["darkModule"]}deg 100% 50%)`}
        onmouseenter={() => highlightedPattern = "darkModule"}
        onmouseleave={() => highlightedPattern = undefined}
        role="none"
    >
    [Dark Module]
    </span> 
    
    <span 
        class={["column", "is-4", "glowy-text", { active: highlightedPattern == "version" }]}
        style:--shadowHue={`hsl(${patternHues["version"]}deg 100% 50%)`}
        onmouseenter={() => highlightedPattern = "version"}
        onmouseleave={() => highlightedPattern = undefined}
        role="none"
    >
    [Version bits]
    </span>
</div>

(The dark module is a bit hard to see, it's next to the top-right corner of the bottom-left finder pattern)

## Codewords? Yeah, I program

There's some confusing terminology if you're not used to it. To make sure we're all on the same page, here's a brief glossary:

 - **Codeword**: A term used in data transmission and error correction. It is some data that is being used in a code system (code as in encoding, not programming code), e.g. reed-solomon error correction.
   - **Data codeword**: A chunk of encoded data, usually part of some larger message
   - **Error correction codeword**: A chunk of data used to detect and/or correct errors. Generated from data codewords.
 
 - **Block**: An array of codewords. Has a fixed size depending on the group.
 - **Group**: An array of blocks. Has a fixed number of blocks, and and all blocks in the same group have the same size.
   - Provides a strict two-tier hierarchy (group -> block -> codeword)

<div class="message is-info">
    <div class="message-header"><p>Note</p></div>
    <div class="message-body">
        The reason for groups and blocks is to facilitate <strong>interleaving</strong> which is explained in <a href="#decoding-pt3-deinterleaving">Decoding Pt.3</a>
    </div>
</div>

## Text manipulation

[For no particular reason](https://www.hackmud.com/) let's assume you have a QR code in the following format:

```js
const qrText = `
█▀▀▀▀▀█ █▀   ███▀ █▄█▀▀▀▄▄▀ ▄▀█▄ ▄▄▄  ▄▄█ █▀▀▀▀▀█
█ ███ █ ▀█▄▄▄  ▄█ ▄▄██▄█▄▄▀▀▄█  ▄▀▀▄▄▄ █▀ █ ███ █
█ ▀▀▀ █ ▄█▄   ▀█▄█ ▀ ██▀▀▀█▄▀▄ ▀ ▄▄ ▀▀▄   █ ▀▀▀ █
▀▀▀▀▀▀▀ █ █ ▀ ▀▄▀ █▄▀ █ ▀ █▄▀ █ █▄▀ █ █▄▀ ▀▀▀▀▀▀▀
  ▀▀█▄▀▄█▀█   ▄██▄ ▀▄ ▀█▀▀█ ▄█▄█▀▀▀▀  ▀█▀███ ▄▀▀▀
▄▄█ ▄▄▀▀▄▀ ██▄██▄ ▄▀██  ▄▀▀█▀ ▄▄█▀█▀▄ ██▀▀▄▀▄█▀▀▀
█▀▄▄  ▀  ▀▄ ▀█▀ ▄ █ ▀  ▄█▀▄█▄ ▀▀▀▀█▄█▄ █▀▄▄ ▄▄▀▀ 
▀  ██▀▀█ █▀ ▀ █  ▄ ▄█▄▀██▄▀ ▀█ ▀▄█ ▀  ▀██▄ ▄▄▄ █▀
  ▀█ ▀▀ ▀  ▀ ▄ █▀▄ ▀▄▀▀ ▄▄   ▄▄ ▄▄  █▀ ▀▄▄ █ ▄▄ ▀
██ ▀█▄▀█▀█ ▄▄▀▄ ▀█▀▀▀ ▀▀▄█▀▄ ▄█ ▄  ▀ ▀ ▀█▄█▀▄▄▀ ▀
█▀██ ▀▀▄█▄ █▀▀█▄▀▀ ▀▄▄█▄█▄▄ ▀ ▀    █▀▄▀▄▀ ██ ▀█▄▀
█ ▀▀█▀▀▀█▄▀▄▀ ▀█ ▄█▀▀▄█▀▀▀█  ▄ ▀▀▀█  ▀▀▀█▀▀▀██ ██
 ▀█▄█ ▀ █▄██▀▄██▄ ▀   █ ▀ █▀▀▀▀▀█ ▀▀▀ ▀ █ ▀ █▀▀ █
 █ ██▀▀▀█▄▄▀▀▀█▄▄▀▄██▄▀████ █▄ █▀ █▄▀▀▀ ▀▀▀▀█  ▀ 
▄█   █▀█ ▀█ ██▀█ ▀█▀▄▀▄  ▀ ▄▀█▄▄ ▀▀█▀█ ▀ ▄▀▀ ▀█▀ 
██▄ ▀▀▀ █  ▄▀ ▄▀  ▀▄██ ▄█▀▄▀▄  ▄ ███▄ ▀▀█▀▀▀  ▀▄▀
▀  ▄█▀▀██ ▄▀█ ▄███ █▀▄███ ▀▄ ▀▀▄ █ ▄█ ▀▀ ▀▄▄▀▄█  
▄ ██ ▀▀ ██▀█▄█▀ ▄█ ▀ ▀█▄▄▀▀▀ ▄█  ▄▀▄▀ █▀█ ▀ ▀█▀█▀
 █ █▄▄▀▀ ▄▄██▄▄█  ▄ ▀▄█ ██▄█ ▀▄▀█▄ ▀▀▀ ██▄▀▄▀▀██ 
 █▄▄ ▀▀  █ ▄▀ ▀▀▀ ▄ ███▄▄▄▄ ▄▄ ▀█ ▄ ▀▄█▀▀ ▀▄ ▀███
▀▀▀   ▀▀▄▄▄ ▄▀▄▀ ▄█▀█ █▀▀▀█ ▄██▀▄▀█ ▀▄███▀▀▀██ ▀▀
█▀▀▀▀▀█  ▀█▄██▀█ █ ▀▄▄█ ▀ █▄▀█▀█ ▀  ▀ ▄▄█ ▀ █▀▀ ▀
█ ███ █ █▀▀▄ ▄ ▄▀ █ ██████▀ ▀███▄▀ █▀█ ▀▀▀█▀██▀▀▄
█ ▀▀▀ █ ▀██ ▄▄▀▀▄▀█ ▀▄█  ▄▄ ▀▀▀█▄▀▀ ▀ █▀ █▄  ▀▀▀█
▀▀▀▀▀▀▀   ▀▀▀▀▀▀ ▀▀ ▀▀  ▀      ▀ ▀  ▀ ▀▀   ▀  ▀▀▀`;
```

If you squint your eyes, it somewhat resembles a QR code. Your phone probably can't scan it. 
Let's parse that text and turn it into something more useful.

Given a coordinate `(x, y)`, we have to get the right character from the text. While each character in a line represents one x coordinate, each line represents two modules. To get the correct row, we need to select the `(y/2)` line

```js
// clean and split up the qr code text into lines for simpler access
const qrLines = qrText.trim().split("\n");

const char = qrLines[Math.floor(y / 2)][x];
```

Now for a detour about binary math. Stay with me, I promise it will be quick.

The text is made up of block characters, such that two modules are stacked vertically in one line of text:

```js
const emptyBlock = " "; // colloquially "space"
const topHalf    = "▀";
const bottomHalf = "▄";
const fullBlock  = "█";
```

If you rotate them 90 degrees clockwise, you can think of them as a two-bit binary number

![each block character in order, with the bit representation below](/img/qr/bits_and_bytes.png)

```js
const blockMap = {
    [emptyBlock]: 0b00, // 0
    [topHalf]:    0b01, // 1
    [bottomHalf]: 0b10, // 2
    [fullBlock]:  0b11  // 3
}
```

With this map, we can turn each character into a number, and then we "extract" the bits we want by using some bitwise operations. 

To get the numerical value we look up the character in the map (`blockMap[char]`).

This still gives us two possible modules. In order to figure out if we want the top or bottom module, we can use the the fact that the lowest bit is `0` when even, and `1` when odd: `y & 1` produces `0` for the top, and `1` for the bottom.

Conveniently, we ordered our bit-representation such that the highest bit corresponds to the top, and the lowest bit is the bottom. We can bit-shift our numerical representation by the result of `y & 1`, ensuring the correct bit is always first.

```js
blockMap[char] >> (y & 1)
```

Last, we need to wrap the result of all of that in one final `& 1`. This is because in the case where `y & 1 == 0`, we don't bit shift at all, and so we return the whole `blockMap[char]`, rather than the top bit.

Putting it all together, we can make a function to get whatever bit we want from our QR code text:

```js
const getModule = (x,y) => {
    const char = qrLines[Math.floor(y / 2)][x];

    return (blockMap[char] >> (y & 1)) & 1;
}
```

Honestly, I'm not sure if these two lines of code are ugly or elegant. Both I guess?

By iterating over each line twice (and with some flexbox magic), we now have a clean QR code.

<!-- <QR qrText={qrText} /> -->

Now you can scan it with your phone. But you don't want spoilers, do you?

# Decoding Pt.1: Metadata

To begin decoding we have to know the QR code `version`, which we can calculate from the size.

```js
const size = QRLines[0].length; // easier to get the width than the height

const version = ((size - 21) / 4) + 1;
```
You can also get it from the version bits on the larger QR codes, if you want to double-check (or perform error correction).

In our case, we have a 49x49 module QR code, which means it's version `8`.

Next we need the format metadata. It's 15 bits long; The top 5 bits contain format data and the bottom 10 are for error correction. It's wrapped around the top-left finder pattern, or next to the bottom-left and top-right patterns. Watch out for the timing pattern and dark module!

![simplified QR code showing the order of format bits](/img/qr/formatbits.png)

As we do not care about error correction we only have to read the top 5 bits, from either one. The format is then masked with these bits: `101010000010010`. Unmasking is performed by `XOR`ing the masked data with the mask.

```js
const formatBits = [];

for(let x = 0; x < 5; x++) 
    formatBits.push(getModule(x, 8));

const format = parseInt(formatBits.join(""), 2) ^ 0b10101;
```

<div class="message is-warning">
    <div class="message-header"><p>Beware of the bit order!</p></div>
    <div class="message-body">
        <p>All binary numbers here are written in the typical <abbr title="Most Significant Bit">MSB</abbr>-><abbr title="Least Significant Bit">LSB</abbr> format, just like other number systems.</p>
        <p>Be careful in which order you read the bits in your implementation to avoid issues with converting from bits to bytes.</p>
    </div>
</div>

The 5 format bits contain: 
    - 2 bits for error correction level
    - 3 bits for the mask pattern

With some simple bitwise operations, we can get their values

```js
const ecLevel = format >> 3;
const mask = format & 0b111;
```

There are 4 error correction levels, and 8 mask patterns

| Level | Binary | Decimal |
|-----|------|-----|
| `M` | `00` | `0` |
| `L` | `01` | `1` |
| `H` | `10` | `2` |
| `Q` | `11` | `3` |

Note that the error correction levels are not in order (from lowest to highest: `L -> M -> Q -> H`)

| Mask | Binary | Formula |
|-----|-------|-------------------------------|
| `0` | `000` | `(y + x) % 2`                 |
| `1` | `001` | `y % 2`                       |
| `2` | `010` | `x % 3`                       |
| `3` | `011` | `(y + x) % 3`                 |
| `4` | `100` | `(~~(y/2) + ~~(x/3)) % 2`     |
| `5` | `101` | `((y*x) % 2 + (y*x) % 3)`     |
| `6` | `110` | `((y*x) % 2 + (y*x) % 3) % 2` |
| `7` | `111` | `((y+x) % 2 + (y*x) % 3) % 2` |

(NB: `~~` is equivalent to `Math.floor()` as long as the number is between `-(2**31)` and `2**31-1`)

In our QR code the top 5 format bits are `00111`. After unmasking, that's `10010`, meaning our error correction is `10` (`2` or `H`) and the mask pattern is `010` (also `2` or `x % 3`).

The mask pattern is a 2D mask applied to the data and error correction codewords before they get placed in the QR code. Mask patterns are expressed as formulas that take in the position of the module and produce cool patterns to further break up the QR code. 

![Mask patterns visualized](/img/qr/mask_patterns.png)

(Yoinked from the [QR code wikipedia page](https://en.wikipedia.org/wiki/QR_code). Note that `i` and `j` are used instead of `x` and `y`, and some of the equations are simplified)

While we're not implementing error correction in this guide, the error correction level will be necessary for deinterleaving later.

# Decoding Pt.2: Reading and Unmasking

Now that we have the mask pattern, we can begin reading the data codewords in the QR code.

Encoded data is split into 8 bit chunks called codewords. The codewords are placed starting from the bottom-right corner tightly packed, snaking up and down, left to right. Immediately following the data codewords are the error correction codewords, similarly masked, interleaved, and snaked left to right. 

The individual bits in each codeword is placed in a zig-zag pattern, in either upwards or downwards direction.

![Diagram showing the order of bits read in a codeword](/img/qr/readorder.png)

If you encounter [functional modules](#functional-modules), skip over them.

![Diagram showing skipping over an alignment pattern](/img/qr/readskip.png)

When you reach the top or bottom, flip the vertical reading direction and continue reading in the next two-module column.

![Diagram showing vertical direction reversing](/img/qr/readflip.png)


The logic for reading data bits is quite simple, despite many diagrams on the internet trying to confuse you.

  - Start at the bottom-right corner and set your vertical direction to up

While you have data to read:

  - Read the module at your current position
  - If you are in an odd column, move one module left
  - Otherwise, move one module vertically and to the right
  - If you are outside the vertical bounds of the QR code:
    - Flip your vertical direction
    - Move one module vertically (so you're back inside)
    - Move two modules left
  - If you are currently on a functional module, repeat the moving logic until you aren't

<div class="message is-warning">
    <div class="message-header"><p>The timing pattern attacks</p></div>
    <div class="message-body">
        <p>Note that this algorithm does not take into account the vertical timing pattern.</p>
        <p>If you are in the 7th column, you must move one additional module to the left.</p>
        <p>However if you don't care about error correction it won't matter as the data codewords don't reach that far into the QR code.</p>
    </div>
</div>

There's are many ways that you could implement reading; The approach I will describe is simple and intuitive, but offers room for optimization, which I encourage you to try yourself.

We will construct a mask containing all the modules that are not data, 

Create a square 2D array the same size as the QR code filled with `0`, and set all the locations with functional modules to `1`. This simplifies reading logic as we can easily check if the module we're on is a functional module to be skipped over.

```js
const skipMask = Array.from({length: size}, () => new Array(size).fill(0));
```

We have to calculate the locations with functional modules as they are different for each QR version. Luckily, most of the areas we're interested in are grouped together and always in the same place. We don't even need all the functional modules, as we're mainly interested in the second half of the QR code.

```js
// a few convenience functions

// set a rectangular region of the skip mask
const setRectangular = (startX, startY, endX, endY) => {
   for(let y = startY; y < endY; y++)
       for(let x = startX; x < endX; x++)
           skipMask[y][x] = 1;
}

// set a square region of the skip mask
const setSquare = (startX, startY, size) =>
    setRectangular(startX, startY, startX + size, startY + size);

// the coordinate of the last module inside the QR code
const end = size - 1;


// finder pattern + version block
setRectangular(end - 11, 0, size, 7);

// bottom border of qr code and format bits
setRectangular(end - 8, 7, size, 9);

// horizontal timing pattern
setRectangular(9, 6, end - 11, 7);
```

Alignment patterns get a little tricky, as each QR code version has different positions. I've omitted most of them for brevity, you can see the full list [here](https://www.thonky.com/qr-code-tutorial/alignment-pattern-locations).

The the positions of each alignment patterns are based on a grid in sync with the timing pattern and spread equally throughout the QR code. The coordinates where each line intersects is the center of an alignment pattern, except where they overlap with finder patterns.

![A QR code with alignment patterns and their coordinates labelled](/img/qr/alignmentpatterns.png)

```js
// an array of alignment pattern row/column positions, for each QR version
const alignmentPatterns = [
    // 7 elements not shown...
    [6, 24, 42],
    // ...
];

const patternPos = alignmentPatterns[version];

// iterate through all alignment patterns to generate all permutations
for(const x of patternPos)
    for(const y of patternPos) {
        // filter disallowed positions
        if(
            (x == 6 && y == 6) ||
            (x == 6 && y == end - 6) ||
            (x == end - 6 && y == 6)
        )
            continue;
        
        // the coordinates are for the center, but setSquare 
        // starts from the top-left corner 
        setSquare(x - 2, y - 2, 5);
    }
```

This will give us a rudimentary "skip mask":

<!-- <QR qrText={qrText} visualize={[["simpleMask", 2]]} /> -->


Next, we need to get the mask function using the mask pattern from the format bits earlier in [Pt.1: Metadata](#decoding-pt1-metadata).

```js
const maskFunctions = [
    // ...
    (x, y) => x % 3 == 0,
    // ...
];

const maskFunction = maskFunctions[mask]
```

Now we can implement the module reading logic.

```js
// start by going up
let direction = -1;

const readBit = (x, y) => {
    // get current module and XOR with the mask
    const bit = getModule(x, y) ^ maskFormula(x, y);

    // calculate the next module position to read, skipping any functional modules
    do {
        if (x & 1) { // left column
            x++; // move right & vertical
            y += direction;
        } else { // right column
            x--; // move left
        }

        // when we reach the top/bottom edge
        if(y < 0 || y == size) {
            y -= direction; // go back
            direction *= -1; // flip reading direction
            x -= 2; // jump to next column
        }

        // if we go OOB (x == -1), there's no more to read
        if(x < 0)
            break;
        
    } while (skipMask[y][x] == 1)

    return [bit, x, y]; 
}
```

And just for good measure, a convenience function is useful too.

```js
const readBits = (x, y, n) => {
    const bits = [];

    while(n-- > 0) {
        let bit;
        [bit, x, y] = readBit(x, y);
        
        bits.push(bit);
    }

    return [bits.join(""), x, y];
}
```

# Decoding Pt.3: Deinterleaving

Deinterleaving is the part many decoding tutorials skip. This is because they often use QR code version 1, where no interleaving happens. The worst part is that the first deinterleaved codeword is always the first one interleaved, so it looks like you're decoding correctly - for the first 8 bits. 

## Groups, blocks, and codewords

The total amount of data stored in each QR code version is fixed. Different error correction levels take up more space - the more error correction data, the smaller the message data. The message data and generated error correction data is split up into 8 bit chunks called codewords, each of which are placed into arrays called blocks, which are then organized into groups.

Each group has a fixed number of blocks, and all blocks inside of a group have the same number of codewords. A QR version can have 1 or more groups, and a group can have 1 or more blocks. Different groups may have different sized blocks. You can find the full list [here](https://www.thonky.com/qr-code-tutorial/error-correction-table).

<div class="message is-info">
    <div class="message-header"><p>How much data?</p></div>
    <div class="message-body">
        <p>
        There are different values for data and error correction codewords, though we are only interested in the data codewords and can ignore error correction data.
        </p>
    </div>
</div>

With this information, we can calculate the total number of data codewords, given any QR code version and `ecLevel`. All we have to do is calculate `numberOfBlocks * codewordsPerBlock` for every group, then sum up the result:

```js
const codewordGroups = [
    // ...
    [ // 8
        [[2,97]],        // L
        [[2,38],[2,39]], // M
        [[4,18],[2,19]], // Q
        [[4,14],[2,15]], // H
    ],
    // ...
];

// the ec levels are not in order for some reason
const ecLevelToIndex = [1, 0, 3, 2]; // M, L, H, Q
const ecIndex = ecLevelToIndex[ecLevel];

const groups = codewordGroups[version][ecIndex];

let totalDataCodewords = groups.reduce(
    (sum, [blocks, codewords]) => sum + (blocks * codewords), 0
);
```

Finally, we can read in all the data codewords by reading 8 modules at a time

```js
const interleavedData = [];

// start at the bottom-right corner
let currentX = end;
let currentY = end;

while(totalDataCodewords-- > 0) {
    let bits;
    [bits, currentX, currentY] = readBits(currentX, currentY, 8);

    interleavedData.push(bits);
}
```

It should look like this:

<!-- <div class="columns">
    <div class="column">
        <QR 
            qrText={qrText}
            bind:this={animatedQR} 
            animate={"bits"}
            {readHistory}
            {animState} 
            {animSpeed}
            bitUpdate={bs => {
                bitString = bs;
            }} />
    </div>
    <div class="column">
        <p><code style="font-size: 0.75rem">{[...bitString.matchAll(/.{1,8}/g)].join(" ")}</code></p>
    </div>
</div> -->


<!-- <div class="buttons" style="margin-bottom: 1rem">
    <button 
        class="button" 
        class:is-success={animState == "paused"}
        class:is-warning={animState == "play"}
        onclick={() => { animState = animState == "play" ? "paused" : "play" }}
    >{animState == "paused" ? "Play" : "Pause"}</button>
    <button 
        class="button is-danger"
        onclick={() => { animatedQR.resetAnim() }}
    >Reset</button>

    <label class="label" for="name">Speed:</label>
     <input name="speed" type="range" min={1} max={5} step={0.1} bind:value={animSpeed}> 
</div>  -->

## Interleaving

Interleaving is the process of splitting up the data and weaving it into itself in a sequential pattern to break it up and help with error correction. 

The process for interleaving is:
 - Take the first codeword
   - Add it in block 0 of group 0
   - Add the next one in block 1 of group 0
   - Add the next one in block 2 of group 0
   - ...
 - Once you've added one codeword in each block in the group 0, repeat the same in group 1
   - Then group 2
   - ...
 - Once you've added each codeword in each block in each group, repeat the above again until you have no more codewords left
   - Take care not to overfill a block. If you've used up all the capacity in a block, continue on to the next block that has available space.

Here's a worked through example, using 15 codewords (represented as hex half-bytes), put into two groups: 
 - Group 0: 
   - 3 blocks that hold 3 codewords each, and 
 - Group 1: 
   - 3 blocks that hold 2 codewords each.

```js
// data to interleave
[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E];

[ // group 0
    [0,6,C], // block 0
    [1,7,D], // block 1
    [2,8,E]  // block 2
];

[ // group 1
    [3,9],   // block 0
    [4,A],   // block 1
    [5,B]    // block 2
];

```

The blocks and groups are then concatenated in order, so the final interleaved data looks like:

```js
//  g0                   g1
//  b0     b1     b2     b0   b1   b2
  [ 0,6,C, 1,7,D, 2,8,E, 3,9, 4,A, 5,B ];
```

Deinterleaving is "simply" reversing this process. As usual there's a number of ways to approach this. 

A naive approach would be to calculate the stride by summing up total number of blocks for all groups and then placing each data codeword into a buffer such that `i % codewordsPerBlock * stride + floor(i / stride)` (where `i` is the index of the interleaved data). This appears to work, however the number of codewords per block is not the same in all the groups. This leads to some characters being corrupted, though a large portion of the data will be readable.

One approach I came up with was "binning". Create arrays for each block in each group and iterate over the data codewords, incrementing counters for which group and block you are in. When incrementing, check if the group you are in is full - if you are, then keep incrementing the group index.

First, to explain the format in which I store group and block information
```js
const codewordGroups = [
    // ...
    [ // 8
        [[2,97]],        // L
        [[2,38],[2,39]], // M
        [[4,18],[2,19]], // Q
        [[4,14],[2,15]], // H
    ],
    // ...
];
```

`codewordGroups` is a 4D array. At the top level is the version.
  - For each version there are 4 error correction arrays (in order from low to high)
    - For every error correction level, there is at least 1 group
      - Each group is an array with two numbers:
        - The number of blocks in a group
        - The number of data codewords in each block

In our example, with a version `8` QR code and `H`igh error correction, we have 2 groups
 - Group 1 has 4 blocks with 14 codewords each
 - Group 2 has 2 block with 15 codewords each

This means that we have `4 * 14 + 2 * 15` = `86` data codewords in total.

You should backtrack to the [reading](#backtrack) section and understand how we calculate the total number of data codewords. That's right, this tutorial has metroidvania elements!

Now to implement deinterleaving:

```js
let currentGroup = 0;
let currentBlock = 0;

const dataBlocks = groups.map(([blocks]) => 
    Array.from({length: blocks}, () => new Array())
);

for(let i = 0; i < interleavedBlocks.length; i++) {
    dataBlocks[currentGroup][currentBlock].push(interleavedData[i]);

    const [blocksInGroup] = groups[currentGroup];

    do {
        if(i == interleavedBlocks.length - 1)
            break; // avoid an infinite loop at the end

        currentBlock += 1;

        if(currentBlock >= blocksInGroup) {
            currentBlock = 0;
            currentGroup += 1;

            if(currentGroup >= groups.length) {
                currentGroup = 0;
            }
        }
    } while(dataBlocks[currentGroup][currentBlock].length >= groups[currentGroup][1])
}
```

This should work for any combination of group and block sizes, though there's definitely room to optimize if you are only targeting a few select QR versions.

To give you an idea of how it should look:

<!-- <QR qrText={qrText} visualize={hoverVis} /> -->

<!-- <GroupHover 
    groups={dataBlocks} 
    colors={groupColors}
    
    hoveron={({g, b}) => hoverVis = groupBlockHoverVis(g, b)}
    hoveroff={() => hoverVis = defaultHoverVis}
    /> -->

<br>

Tip: I'm interactive too! Hover over a block to isolate it on the QR code<br>

Last but not least, we just concatenate all the groups and blocks in order to get our final bit string

```js
const encodedData = dataBlocks.flat(3).join(""); // isn't ES6 nice
```

Here's what that looks like in our QR code:

<!-- <p>
    {#each dataBlocks.flat(3).map(toByte) as byte, i}
    <code style:margin-right={(i+1) % 4 == 0 ? "1rem" : ""}>{byte}</code>&emsp;
    {#if (i+1) % 16 == 0}
    <br>
    {/if}
    {/each}
</p> -->

(I've converted the bits to bytes for your viewing pleasure)

# Decoding Pt.4: Decoding the data

We're now in the final stretch. We have our raw bits hot off the QR code and carefully deinterleaved. We just need to turn those bits into something useful.

Luckily for us, it's not too hard. The first 4 bits are the encoding type, and despite what you may expect there's only 5 encoding modes:

| Type         | Bits   |
| ------------ | ------ |
| Numeric      | `0001` |
| Alphanumeric | `0010` |
| Byte         | `0100` |
| Kanji        | `1000` |
| ECI          | `0111` |

Most of these are self-explanatory:
  - Numeric encodes only numbers 0-9
  - Alphanumeric encodes only letters, numbers, and a few symbols
  - Bytes can be any data, but usually interpreted as UTF-8 text
  - Kanji uses double-byte Shift-JIS

ECI is a little weird. It's not an encoding format in of itself, but rather an indicator that multiple encoding formats are used. It's quite rare, and not supported by every QR code reader. Aside from that, you can find the details for each encoding mode [here](https://www.thonky.com/qr-code-tutorial/data-encoding#step-3-encode-using-the-selected-mode). You'll most commonly encounter alphanumeric and bytes modes (maybe Kanji if you're dealing with 日本語).

The following 8 bits are the length. The number of length bits is actually dependent on the QR size and encoding type, which you can find the reference for [here](https://www.thonky.com/qr-code-tutorial/data-encoding#versions-1-through-9). We'll just deal with bytes mode here, because it's the simplest to decode.

```js
const encoding = parseInt(encodedData.slice(0,4), 2);
const length = parseInt(encodedData.slice(4,12), 2);
```

If you scroll up a bit and read off the first two bytes, you can see our QR code has an encoding of `4` or `0100` (bytes) and our length is `41` hex or `65` bytes total.

Immediately following the encoding and length is the data itself.

```js
const dataBitstring = encodedData.slice(12, 12+length*8);

// split up the bit string into 8-bit strings with some magical regex
const dataBits = [...dataBitstring.matchAll(/.{1,8}/g)]; 

const decoded = dataBits
    .map(bits => parseInt(bits, 2))
    .map(num => String.fromCharCode(num))
    .join("")
```

Finally, we have our big reveal, the secret message you've undoubtedly been dying to read:

<!-- <p>
    <code>{decoded}</code>
</p> -->

Oh. Not sure what that means, really. Maybe you should carry on working on t2 scraper?

PS: If you've been paying attention, you'll notice that we only have 65 bytes, but our qr code has 86 codewords total. If you look closely, you'll see a repeated pattern of `ec` and `11` at the end. This is actually intentional padding, used to fill up any remaining space. It's not that interesting unless you're worried about data integrity...

<style lang="sass">
    .glowy-text
        text-shadow: 0 0 10px var(--shadowHue)

        &.active
            text-shadow: 0 0 10px var(--shadowHue), 0 0 20px var(--shadowHue), 0 0 20px var(--shadowHue), 0 0 25px var(--shadowHue)
</style>